<% content_for :title, "Robin AI playground: #{@response_source.name}" %>

<section class="h-full w-full flex flex-col px-8 py-4">
  <header class="flex items-center" role="banner">
    <a href="<%= super_admin_response_source_path(@response_source) %>" class="text-woot-500 hover:underline mr-4">Back</a>
    <div class="border border-solid border-slate-100 text-slate-700 mr-4 p-2 rounded-full">
      <svg width="24" height="24"><use xlink:href="#icon-mist-fill" /></svg>
    </div>
    <div class="flex flex-col h-14 justify-center">
      <h1 class="text-base font-medium  text-slate-900" id="page-title">
        Robin AI playground
      </h1>
      <p class="text-sm text-slate-600">Chat with the source <span class="font-medium"><%= @response_source.name %></span> and evaluate itâ€™s efficiency. </p>
    </div>
  </header>

  <div class="flex-1">
    <div id="chat" class="px-8 pt-5">
    <!-- Chat messages will be appended here -->
    </div>
  </div>
  <div class="w-full pt-2 md:pt-0 dark:border-white/20 md:border-transparent md:dark:border-transparent md:w-[calc(100%-.5rem)]">
    <textarea id="messageInput" rows="4" class="resize-none block p-2.5 w-full text-sm text-gray-900 bg-gray-50 rounded-lg border !outline-2 border-gray-300 focus:ring-woot-500 focus:border-woot-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-woot-500 dark:focus:border-woot-500" placeholder="Type a message..." autofocus autocomplete="off"></textarea>
  </div>
</section>

<script>
  document.addEventListener("DOMContentLoaded", function() {
    let messagesHistory = []; // Store the message History, so far
    const messageInput = document.getElementById("messageInput");
    const chat = document.getElementById("chat");

    messageInput.addEventListener("keydown", function(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault(); // Prevent default to avoid new line on enter key
        const message = messageInput.value.trim();
        if (message) {
          appendMessage("You", message.replace(/\n/g, "<br>")); // Replace new lines with <br> for HTML display
          sendMessageToServer(message);
          messageInput.value = ''; // Clear textarea after sending
        }
      }
    });

    function markdownToHtml(markdown) {
      let html = markdown;

      // First, ensure that line breaks are standardized to <br> tags
      html = html.replace(/(\r\n|\r|\n)/g, '<br>');

      // Then, replace sequences of two or more <br> tags with exactly two <br> tags
      html = html.replace(/(<br>\s*){2,}/gi, '<br><br>');

      // Basic Markdown conversions
      html = html
        .replace(/(\*\*)(.*?)\1/g, '<strong>$2</strong>') // Bold **text**
        .replace(/(__)(.*?)\1/g, '<strong>$2</strong>') // Bold __text__
        .replace(/(\*)(.*?)\1/g, '<em>$2</em>') // Italic *text*
        .replace(/(_)(.*?)\1/g, '<em>$2</em>') // Italic _text_
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a target="_blank" href="$2">$1</a>'); // Link [text](url)

      // Return the converted HTML
      return html;
    }

    function appendMessage(sender, message) {
      const chat = document.getElementById("chat");
      const isUser = sender === "You";
      const messageBubble = document.createElement("div");
      const bubbleContent = document.createElement("div");
      const senderIcon = document.createElement("div");

      // Set the appropriate styles for user vs bot
      messageBubble.className = isUser ?  'flex items-end mb-2 justify-end' : 'flex items-end mb-2';
      bubbleContent.className = isUser ? 'text-sm md:text-base bg-woot-500 text-white rounded px-4 py-2 shadow max-w-[60%] leading-normal' : 'text-sm md:text-base bg-white rounded px-4 py-2 shadow max-w-[60%] leading-normal' ;
      senderIcon.className = isUser ? 'flex items-center h-8 w-8 rounded-full bg-gray-500 text-white justify-center ml-2' : 'flex items-center h-8 w-8 rounded-full bg-woot-500 text-white justify-center mr-2' ;
      senderIcon.innerText = isUser ? 'U' : 'B'; // Assuming 'U' for User and 'B' for Bot

      // Convert Markdown to HTML and insert into bubble
      bubbleContent.innerHTML = markdownToHtml(message);

      // Append elements based on sender
      if (isUser) {
        messageBubble.appendChild(senderIcon);
        messageBubble.appendChild(bubbleContent);
      } else {
        messageBubble.appendChild(senderIcon);
        messageBubble.appendChild(bubbleContent);

      }

      // Append the message bubble to the chat
      chat.appendChild(messageBubble);
      chat.scrollTop = chat.scrollHeight; // Scroll to the bottom
    }

    async function sendMessageToServer(message) {
      const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
      const messageInput = document.getElementById("messageInput");

      // Disable the textarea to prevent further input while processing
      messageInput.disabled = true;

      try {
        const response = await fetch(window.location.href, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          },
          body: JSON.stringify({
            message: message,
            previous_messages: messagesHistory // Include the conversation history in the payload
          }),
          credentials: 'include'
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        /// push messages to the history
        messagesHistory.push({ type: "user", message: message });
        messagesHistory.push({ type: "bot", message: data.message });

        appendMessage("Bot", data.message.replace(/\n/g, "<br>")); // Adjust based on your server's response
      } catch (error) {
        console.error("Failed to send message to server:", error);
        appendMessage("Bot", "Error: Could not retrieve response. Please check the console for more details.");
      } finally {
        // Re-enable the textarea regardless of the request's outcome
        messageInput.disabled = false;
        messageInput.focus(); // Optionally, refocus the textarea for convenience
      }
    }
  });
</script>
