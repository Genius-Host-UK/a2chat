<% content_for(:title) do %>
 Chat with <%= @response_source.name %>
<% end %>
<section class="main-content__body h-full">
  <div class="flex flex-col h-full">
    <header class="flex mx-8 pb-4 items-center border-b border-solid border-slate-100" role="banner">
      <div class="border border-solid border-slate-100 text-slate-700 mr-4 p-2 rounded-full">
        <svg width="24" height="24"><use xlink:href="#icon-settings-2-line" /></svg>
      </div>
      <div class="flex flex-col h-14 justify-center">
        <h1 class="text-base font-medium leading-6 text-slate-900" id="page-title">
          <%= content_for(:title) %>
        </h1>
        <a href="<%= super_admin_response_source_path(@response_source) %>" class="text-blue-500 hover:underline">Back to  <%= @response_source.name %> </a>
      </div>
    </header>
 
    <div class="flex-1">
      <div id="chat" class="px-8 pt-5">
      <!-- Chat messages will be appended here -->
      </div>
    </div>
    <div class="w-full pt-2 md:pt-0 dark:border-white/20 md:border-transparent md:dark:border-transparent md:w-[calc(100%-.5rem)]">
      <textarea id="messageInput" class="" placeholder="Type a message..." autofocus autocomplete="off"></textarea>
    </div>
  </div>
</section>

<script>
  document.addEventListener("DOMContentLoaded", function() {
    let messagesHistory = []; // Store the message History, so far
    const messageInput = document.getElementById("messageInput");
    const chat = document.getElementById("chat");

    messageInput.addEventListener("keydown", function(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault(); // Prevent default to avoid new line on enter key
        const message = messageInput.value.trim();
        if (message) {
          appendMessage("You", message.replace(/\n/g, "<br>")); // Replace new lines with <br> for HTML display
          sendMessageToServer(message);
          messageInput.value = ''; // Clear textarea after sending
        }
      }
    });

    function markdownToHtml(markdown) {
      let html = markdown;

      debugger;// First, ensure that line breaks are standardized to <br> tags
      html = html.replace(/(\r\n|\r|\n)/g, '<br>');

      // Then, replace sequences of two or more <br> tags with exactly two <br> tags
      html = html.replace(/(<br>\s*){2,}/gi, '<br><br>');

      // Basic Markdown conversions
      html = html
        .replace(/(\*\*)(.*?)\1/g, '<strong>$2</strong>') // Bold **text**
        .replace(/(__)(.*?)\1/g, '<strong>$2</strong>') // Bold __text__
        .replace(/(\*)(.*?)\1/g, '<em>$2</em>') // Italic *text*
        .replace(/(_)(.*?)\1/g, '<em>$2</em>') // Italic _text_
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a target="_blank" href="$2">$1</a>'); // Link [text](url)
      
      // Return the converted HTML
      return html;
    }

    function appendMessage(sender, message) {
      const chat = document.getElementById("chat");
      const isUser = sender === "You";
      const messageBubble = document.createElement("div");
      const bubbleContent = document.createElement("div");
      const senderIcon = document.createElement("div");
      
      // Set the appropriate styles for user vs bot
      messageBubble.className = isUser ?  'flex items-end mb-2 justify-end' : 'flex items-end mb-2';
      bubbleContent.className = isUser ? 'text-sm md:text-base bg-woot-500 text-white rounded px-4 py-2 shadow max-w-[60%] leading-normal' : 'text-sm md:text-base bg-white rounded px-4 py-2 shadow max-w-[60%] leading-normal' ;
      senderIcon.className = isUser ? 'flex items-center h-8 w-8 rounded-full bg-gray-500 text-white justify-center ml-2' : 'flex items-center h-8 w-8 rounded-full bg-woot-500 text-white justify-center mr-2' ;
      senderIcon.innerText = isUser ? 'U' : 'B'; // Assuming 'U' for User and 'B' for Bot

      // Convert Markdown to HTML and insert into bubble
      bubbleContent.innerHTML = markdownToHtml(message);

      // Append elements based on sender
      if (isUser) {
        messageBubble.appendChild(senderIcon);
        messageBubble.appendChild(bubbleContent);
      } else {
        messageBubble.appendChild(senderIcon);
        messageBubble.appendChild(bubbleContent);
        
      }

      // Append the message bubble to the chat
      chat.appendChild(messageBubble);
      chat.scrollTop = chat.scrollHeight; // Scroll to the bottom
    }

    async function sendMessageToServer(message) {
      const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
      const messageInput = document.getElementById("messageInput");

      // Disable the textarea to prevent further input while processing
      messageInput.disabled = true;
      
      try {
        const response = await fetch(window.location.href, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          },
          body: JSON.stringify({ 
            message: message,
            previous_messages: messagesHistory // Include the conversation history in the payload
          }),
          credentials: 'include'
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();

        /// push messages to the history
        messagesHistory.push({ type: "user", message: message });
        messagesHistory.push({ type: "bot", message: data.message });

        appendMessage("Bot", data.message.replace(/\n/g, "<br>")); // Adjust based on your server's response
      } catch (error) {
        console.error("Failed to send message to server:", error);
        appendMessage("Bot", "Error: Could not retrieve response. Please check the console for more details.");
      } finally {
        // Re-enable the textarea regardless of the request's outcome
        messageInput.disabled = false;
        messageInput.focus(); // Optionally, refocus the textarea for convenience
      }
    }
  });
</script>

